{"cells":[{"kind":2,"language":"javascript","value":"log(1)\nlog(3n)\nlog(Principal.fromText(\"aaaaa-aa\"))\nlog(Uint8Array.from([233, 2, 112]))\nlog([1, 2, 3])\nlog({ name: \"Yeti\", age: 233 })\n\n// Open View/ Output and select 'Blast'\n// log outputs in two places\n// - notebook results - using toState and JSON.stringify\n// - output panel - using util.inspect\n"},{"kind":2,"language":"javascript","value":"// To make a global variable\nlet something = 'hello'\nglobal({ something })\n\nlet not_here = 'nope' // not in global"},{"kind":2,"language":"javascript","value":"log(something)\n"},{"kind":2,"language":"javascript","value":"// See how errors look like\nlog(not_here)"},{"kind":1,"language":"markdown","value":"# IC BLAST JS LIBRARY\n\nicblast can be found here https://github.com/infu/icblast\nyou can use it outside of notebooks\n\n## Differences ICBLAST <-> AGENTJS\n\nICBLAST is wrapping around Agentjs and provides extra convenience and functionality. It is very opinionated.\nWhat it does: converts all input, passes it to Agentjs actor, then converts the output and returns it.\n\n\n# Opinions:\n\n### Opt has to be undefined not `[]`\nThe main argument against is that Opt Opt Opt Nat8 is valid candid. However, my opinion is that nobody should create APIs that differentiate opt levels. `{param:[]}` `{param:[[]]}` and `{param:[[[]]]}` should be treated the same.\nwith agentjs you had to write ` {parm : [[[3]]]} ` or `{parm: []}` with icblast you have to write ` {parm:3} ` or `{}`\n\nUsing agentjs directly:\n```\nicrc1_transfer({\"to\":{\"owner\":Principal.fromText(\"ryjl3-tyaaa-aaaaa-aaaba-cai\"),\"subaccount\":[]},\n\"fee\":[],\"memo\":[],\"from_subaccount\":[],\"created_at_time\":[],\"amount\":123})\n```\nUsing icblast:\n```\nicrc1_transfer({to: {owner: \"ryjl3-tyaaa-aaaaa-aaaba-cai\"}, amount: 123})\n```\nBoth are doing the same thing. Responses also get the same treatment.\n\n### Err has to be thrown not returned\nUsing agentjs:\n```\nlet resp = await can.balance();\nif (\"Err\" in resp) throw resp.Err;\nlet balance = resp.Ok.e8s;\n```\nYou can also write this:\n```\nlet {Ok : {e8s : balance}} = await can.balance();\n// balance = 123123\n``` \nBut then when the canister returns Err, it won't propagate correctly and you will see something like \"Error: Not found e8s in undefined\" instead of \"Canister error : account not found\"\n\nWith Icblast: \n```\nlet {e8s: balance} = await can.balance();\n```\n\n\n\n### Responses should be easily serializable, so they can get stored in app state\ntoState(...) will convert nested object values:\n- principal -> string principal\n- uint8array -> hex string\n- other typed arrays -> array\n- biging -> string bigint\n\ntoState is optional\n```\nlet x = await can.get_things()\nlet sum = x + 1_000n;\n// also handle binary data \n// when you are ready and want to put in state\nsetState(toState(x));\n// or\nconsole.log(JSON.stringify(toState(x))); // you will get error if trying to serialize obj with bigint without toState\n// also (without toState) Uint8Array will become an object {0:123, 1:221, 3:123,...}\n```\ntoState will have everything converted, serializable, and ready to be stored in state.\nWithout icblast's toState, you will have uint8arrays and bigints nested in your responses which will cause trouble in state, React, Redux, etc..  \n\n### Actor has to easily handle serialized values:\nOnce stored in state with toState, the values can be easily used in calls.\nExample: In case it stumbles upon a string hex when expecting uint8array, it will convert it automagically :unicorn:.  It knows it's looking for a Principal and it's fed a string, so why not try to covert it? It will throw if it's wrong\n\n   - string principals -> principals\n   - string hex (accounts & subaccounts) -> Uint8array\n   - string bigint -> bigint\n\nThis is valid:\n```js\nledger.transfer({\nowner: \"ryjl3-tyaaa-aaaaa-aaaba-cai\",\nsubaccount:\"ffee00\",\namount: \"232423234234234\"})\n```\n\nNotice: Tuples are a bit different\n\n(?Nat,?Nat,?Nat)\n\nagentjs -> ([],[],[]) or ([],[32],[])\n\nicblast -> (undefined, undefined, undefined) or (undefined, 32, undefined)\n"}]}