{"cells":[{"kind":1,"language":"markdown","value":"## Not finished yet "},{"kind":2,"language":"javascript","value":"const wallet_id = \"bnz7o-iuaaa-aaaaa-qaaaa-cai\"; // The reason to use a wallet is to be able to create SNS later, it requires cycles.\n\n// Import external ESM modules\nconst {default : sha256} = await import(\"https://cdn.jsdelivr.net/npm/sha256@0.2.0/+esm\");\nconst gzip = await import(\"https://cdn.jsdelivr.net/npm/gzip-js@0.3.2/+esm\"); \nconst mime = await import(\"https://cdn.skypack.dev/mime-types?dts\"); \nconst {default: plimit} = await import(\"https://cdn.jsdelivr.net/npm/p-limit@4.0.0/+esm\"); // So we can limit the concurrent async requests. Promise.all will crash vscode if too many requests are made.\n\nlet local = icblast({ identity, local: true, local_host: \"http://localhost:8080\" });\nlet assetcan = await local(\"q4eej-kyaaa-aaaaa-aaaha-cai\");\nlet wallet = await local(wallet_id, \"wallet\");\n\nglobal({ assetcan, local, wallet, sha256, gzip, mime, plimit});"},{"kind":1,"language":"markdown","value":"### Check what is inside the asset canister currently\n\nStart a proxy `icx-proxy --address 127.0.0.1:8123 --replica http://localhost:8080 --dns-alias 0.lvh.me:q4eej-kyaaa-aaaaa-aaaha-cai`\n\nThen you can open your asset canister here\n<http://0.lvh.me:8123/>"},{"kind":2,"language":"javascript","value":"\nawait assetcan.list({}).then(log);"},{"kind":1,"language":"markdown","value":"### Grant permissions to 'Prepare' and 'Commit'"},{"kind":2,"language":"javascript","value":"// give prepare permission\nawait walletProxy(wallet, assetcan).grant_permission({\n  permission:{Prepare:null},\n  to_principal:me\n})\n\n// give commit permission\nawait walletProxy(wallet, assetcan).grant_permission({\n    permission:{Commit:null},\n    to_principal:me\n  })"},{"kind":1,"language":"markdown","value":"### Replace single file"},{"kind":2,"language":"javascript","value":"const zipped_file = gzip.zip(\"Hello World Single File\");\n\nawait assetcan.store({\n  key: \"/index.html\",\n  content: zipped_file,\n  sha256: sha256(zipped_file),\n  content_type: \"text/html\",\n  content_encoding: \"gzip\"\n}).then(log);\n"},{"kind":1,"language":"markdown","value":"### Prepare & commit a batch"},{"kind":2,"language":"javascript","value":"const limit = plimit(3); // Max 10 concurrent requests\nconst delay = (x) => new Promise((resolve) => setTimeout(() => resolve(\"hello\"), x*1000));\n\n//let x = await limit(() => delay());\nlet x = await Promise.all([1, 2, 3].map((x) => limit(() => delay(x)) ));\nlog(x)"},{"kind":2,"language":"javascript","value":"\n// Get all files in a directory [[path, url]]\nconst filetree = async (dir, urldir = \"/\") => {\n    const dirfiles = await readDir(dir);\n    let files = [];\n    for (let f of dirfiles) {\n        if (f[1] === 1) files.push([dir + \"/\" + f[0], urldir + f[0]]);\n        else if (f[1] === 2) files.push(...await filetree(dir + \"/\" + f[0], urldir + f[0] + \"/\"));\n    }\n   \n    return files\n}\n\n// Split a file into 1MB chunks\nconst chunkfile = (ua) => {\n    let size = ua.length;\n    let chunkSize = 1024 * 1024;\n    let chunks = Math.ceil(size / chunkSize);\n    let r = [];\n    for (let i = 0; i < chunks; i++) {\n      r.push(ua.slice(i * chunkSize, (i + 1) * chunkSize));\n    }\n    return r;\n}\n  \nglobal({ filetree, chunkfile});"},{"kind":2,"language":"javascript","value":"const {default : sha256} = await import(\"https://cdn.jsdelivr.net/npm/sha256@0.2.0/+esm\");\n\nconst files = await filetree(\"./simple_project/frontend\");\n\nconst limit = plimit(3); // Max 10 concurrent requests\n\nawait assetcan.clear({}); // Will clear chunks so it has to be done before creating a batch\n\nconst { batch_id } = await assetcan.create_batch({});\n\nconst operations = await Promise.all(files.map(async ([path, urlpath]) => {\n    const filebin = await readFile(path);\n    const mimetype = mime.lookup(path);\n    const content_encoding = mimetype.indexOf(\"image/\") === -1 ? \"gzip\" : \"identity\"; // not sure why plain binary is called 'identity'?\n    const processed_file = content_encoding === \"gzip\" ? gzip.zip(filebin) : filebin;\n\n    const chunks = chunkfile(processed_file);\n\n    let chunk_ids = await Promise.all(chunks.map((chunk) => limit(() => assetcan.create_chunk({\n        content: chunk,\n        batch_id\n    })))).then(x => x.map(x => x.chunk_id));\n\n   \n    return [{\n        CreateAsset: {\n            key: urlpath,\n            content_type: mimetype,\n        }\n    },\n    {\n        SetAssetContent: {\n            key: urlpath,\n            chunk_ids,\n            content_encoding,\n            sha256: sha256(processed_file)\n        }\n    }]\n})).then(x => x.flat());\n\nlog(operations);\n\nawait assetcan.commit_batch({\n    batch_id,\n    operations\n}).then(log);\n"}]}