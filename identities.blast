{"cells":[{"kind":2,"language":"javascript","value":"log([\"My blast identity is: \",identity.getPrincipal() ,\" same as \",me])\n\n// You can create another icblast factory with it. \nlet ic2 = icblast({ identity }); \nlet can = await ic2(\"aaaaa-aa\");\n\n// Or you can have anon identity factory\nlet icanon = icblast(); \nlet cananon = await icanon(\"aaaaa-aa\");\n\n// Or you can have hashIdentity factory, great for testing\n// hashIdentities will always be the same, downside is, they are in your code.\nlet john_identity = hashIdentity(\"John.OPHWEORWHERO\");\nlet john_ic = icblast({ identity: john_identity });\n\nlet john_can = await john_ic(\"aaaaa-aa\");\n\nlet peter_identity =  hashIdentity(\"Peter.weRWOPHWEORWHERO\");\nlet peter_ic = icblast({ identity: peter_identity }) \n\nlet peter_can = await peter_ic(\"aaaaa-aa\");"},{"kind":2,"language":"javascript","value":"// This is how identity delegation works\n\n// This identity will be a secret\nlet root = hashIdentity(\"root.WOIERHWOEHRWOERHWOERH\"); \n\n// This identity will be shared\nlet temp = hashIdentity(\"temp.POWEJRPOJ@#%$)WUER)@#@#@#@\");\n\nlog([\n  { name: \"Root\", principal: root.getPrincipal() },\n  { name: \"Temp\", principal: temp.getPrincipal() },\n]);\n\nglobal({ root, temp });"},{"kind":2,"language":"javascript","value":"// Root delegates / signs the temp identity and allows it to operate as root identity for limited time.\nconst rootToTemp = await DelegationChain.create(\n    root,\n    temp.getPublicKey(),\n    new Date(1609459200000)\n  );\n  \n// Recreate it\nlet temp_delegated = new DelegationIdentity(temp, rootToTemp);\n\n// This object doesn't keep private keys and can be safely passed\n// Having the temp identity and delegation will not give you access to the root identity private key\nlog(rootToTemp.toJSON());\n\n// This is the recreated identity. It should have the same principal as root identity\nlog(temp_delegated.getPrincipal());"}]}