{"cells":[{"kind":2,"language":"javascript","value":"// UNDER CONSTRUCTON\n// ALPHA - DO NOT USE THIS IN PROJECTS. Major changes will be made.\n\nconst encodeTokenId = (slot, index) => {\n  let t = (Number(slot) << 16) | Number(index);\n  return t;\n};\n\nconst decodeTokenId = (t) => {\n  t = Number(t);\n  let slot = t >> 16;\n  let index = t & 65535; // 16 bits\n  return { slot, index };\n};\n\nconst TextToSlot = (aid, range) => {\n  let a = typeof aid === \"string\" ? fromHexString(aid) : aid;\n\n  return (\n    Number(range[0]) +\n    (bytesArrayToNumber(a.slice(-4)) % (1 + Number(range[1] - range[0])))\n  );\n};\n\nconst numberToBytesArray = (n, size) => {\n  n = Number(n);\n  const a = Array(size).fill(0);\n\n  for (let i = 0; i < size; i++) {\n    a[i] = n & 255;\n    n = n >>> 8;\n  }\n  return new Uint8Array(a.reverse());\n};\n\nconst bytesArrayToNumber = (a) => {\n  let n = 0;\n  for (let i = a.length - 1; i >= 0; i--) {\n    n += Math.pow(256, a.length - i - 1) * a[i];\n  }\n  return n;\n};\n\nconst fromHexString = (hexString) =>\n  hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16));\n\nconst PrincipalFromIdx = (idx) => {\n  return Principal.fromUint8Array([...numberToBytesArray(idx, 8), 1, 1]);\n};\n\nconst PrincipalFromSlot = (space, idx) => {\n  let start = Number(space[0][0]);\n  return PrincipalFromIdx(start + Number(idx));\n};\n\nclass AnvilClass {\n  config = false;\n\n  constructor(ic) {\n    this.ic = ic;\n  }\n\n  async init() {\n    let router = await ic(\"kbzti-laaaa-aaaai-qe2ma-cai\");\n    this.config = await router.config_get();\n  }\n\n  check_init() {\n    if (!this.config) throw new Error(\"Anvil not initialized\");\n  }\n\n  double_await(me) {\n    return new Proxy(me, {\n      get: function (target, propKey, receiver) {\n        return async (...args) => {\n          return (await me)[propKey](...args);\n        };\n      },\n    });\n  }\n\n  accountCanister(aid) {\n    return PrincipalFromSlot(\n      this.config.space,\n      TextToSlot(aid, this.config.account)\n    );\n  }\n\n  pwrCanister(aid) {\n    return PrincipalFromSlot(\n      this.config.space,\n      TextToSlot(aid, this.config.pwr)\n    );\n  }\n\n  nftCanister(nftid) {\n    let { slot, index } = decodeTokenId(nftid);\n    return PrincipalFromSlot(this.config.space, slot);\n  }\n\n  account(aid) {\n    this.check_init();\n    return this.double_await(this.ic(this.accountCanister(aid).toText()));\n  }\n\n  pwr(aid) {\n    this.check_init();\n    return this.double_await(this.ic(this.pwrCanister(aid).toText()));\n  }\n\n  nft(nftid) {\n    this.check_init();\n    return this.double_await(this.ic(this.nftCanister(nftid).toText()));\n  }\n}\n\nlet aid = AccountIdentifier.fromPrincipal({ principal: me });\n// 09f82d6222c53e502fde4cea8ed9ef78ecaf40b43a755bdfa41b5976b94f73b9\nlog(aid.toHex());\n\nlet au = aid.toUint8Array();\nlet anvc = new AnvilClass(ic);\nawait anvc.init();\n\nconst anv = {\n  // nft\n  nft_bearer: (nft) => anvc.nft(nft).metadata(nft),\n  nft_metadata: (nft) => anvc.nft(nft).metadata(nft),\n  nft_transfer: (args) => anvc.nft(args.token).transfer(args),\n  nft_supply: (nft) => anvc.nft(nft).supply(nft),\n  nft_set_price: (args) => anvc.nft(args.token).set_price(args),\n  nft_claim_link: (args) => anvc.nft(args.token).claim_link(args),\n  nft_burn: (args) => anvc.nft(args.token).burn(args),\n  nft_allowance: (args) => anvc.nft(args.token).allowance(args),\n  nft_use: (args) => anvc.nft(args.token).use(args),\n\n  // acc\n  list_nfts: (...arg) => anvc.account(arg[0]).list(...arg),\n\n  // pwr\n  nft_mint: (...args) => anvc.pwr(args[1].user.address).nft_mint(...args),\n\n  ft_balance: (arg) => anvc.pwr(arg.user.address).balance(arg),\n  nft_recharge: (...args) =>\n    anvc\n      .pwr(args[1].user.address)\n      .nft_recharge(decodeTokenId(args[1].token).slot, ...args),\n  nft_purchase: (...args) =>\n    anvc\n      .pwr(args[1].user.address)\n      .nft_purchase(decodeTokenId(args[1].token).slot, ...args),\n  ft_transfer: (args) => anvc.pwr(args.from.address).transfer(args),\n};\n\nlet nfts = await anv\n  .list_nfts(au, 0, 10)\n  .then((x) => x.filter((a) => a !== 0n));\n\nfor (let nft of nfts) {\n  let meta = await anv.nft_metadata(nft);\n  log(meta.ok.data.name);\n}\n\nawait anv.nft_transfer({token: nfts[0], from:{address: au}, to:{address: \"AE09F8D5E6E5B5CCE806A0FD784A8738B8B69297A868298DD52947F9CE8A843F\"}, memo:[]}).then(log)\n\nlet balance = await anv.ft_balance({ user: { address: au } });\nlog(balance);\n\nawait anv\n  .ft_transfer({\n    from: { address: au },\n    to: {\n      address:\n        \"AE09F8D5E6E5B5CCE806A0FD784A8738B8B69297A868298DD52947F9CE8A843F\",\n    },\n    token: 2,\n    memo: [],\n    amount: balance.anv - balance.oracle.anvFee,\n  })\n  .then(log);\n"}]}